= CORS
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: cors, api gateway, gateway, policy

[%autowidth.spread,cols="a,a"]
|===
>s| Policy name | cross-origin resource sharing (CORS)
>s| Summary      | Enables access to resources residing in external domains
>s| Category | Compliance
>s| First Mule version available | v4.1.1
.1+>.^s| Returned Status Codes
| No return codes exist for this policy
|===

CORS is a mechanism by which a web application can access resources that are defined in another domain. Browsers implement this standard by default. The CORS policy complies with the https://fetch.spec.whatwg.org/[CORS W3C recommendation] standards.

To know why you might need to apply the CORS policy to your backend, you must first understand what are origins and cookies, and how a web page can be misused.

== Origin

At a very basic level, an origin consists of:

* URI Scheme: `http://``
* Host Name: `www.example.com`
* Port Number: `8080`

Any two origins are considered equal only if all these three parameters match. For more information, see https://tools.ietf.org/html/rfc6454[RFC 6454 - The Web Origin Concept]


== HTTP Cookies

HTTP Cookies are a reliable mechanism for websites to retain stateful information. Most commonly, web servers use authentication cookies to know whether a user is logged in and using which account are they logged in. For more information, see https://www.ietf.org/rfc/rfc6265.txt[RFC 6265].

To avoid (or deter?) malicious attackers from exploiting cookies when a web page invoked another web page, the SOP (Same-origin Policy) was introduced. For example, attackers might obtain your bank’s login cookie and query the bank’s API on your behalf if you attempted to access a malicious web page.  

With the SOP, scripts can access data from another web page only if the caller web page has the same origin. For more information about origins, see https://en.wikipedia.org/wiki/Same-origin_policy[Wikipedia].

The following example illustrates the origin of the web page the same as the origin section, http://www.example.com:8080:

image:cors-policy-sop-example.png][SOP Example,95%,85%]

Because the SOP is highly restrictive, access from one sub-origin to another or to external hyperlinks do not work on webpages. For example, if an origin `www.testapply.com` has two sub-origins, `www.eng.testapply.com` and `www.docs.testapply.com`, communication between the two sub-origins is denied. Additionally, any hyperlinks to external websites from any of the sub-origins is also denied.

To circumvent this problem, web browsers implemented the CORS standard, which validates the web server and accepts the request if the validation is successful.

In the bank example mentioned in the previous section, the bank’s login server can implement the server-side protocol for CORS, allowing only to be queried from their web page. Once the check is in place, no web page can query the login API from a domain other than the bank’s domain.

== CORS on the Client-Side

The CORS algorithm on the client-side consist of the following parts:

* Determining whether the request is complex (and potentially dangerous) and sending a ‘preflight’ request to verify whether the server accepts the origin.
* Executing the actual request and validating that the server responds correctly and accepts the origin.

A ‘preflight’ is a request (using OPTIONS as HTTP method) for the web browser to inform the backend server the identity (origin and a few other headers) of the web page that is trying to perform the request. If the backend does not accept the origin, the backend server responds to the request without a specific header (Access-Control-Allow-Origin). The client then understands that the page’s origin is not allowed in that server and does not execute the actual request.

The following diagram shows the XMLHttpRequest (XHR) in JavaScript flow for determining whether to execute the actual request:

== CORS Algorithm

The CORS policy is a two-step algorithm: 

* If the request is considered to be ‘complex’ (see the previous client side diagram for XHR) then a preflight request needs to be executed. 
+
If the server does not return the proper CORS response headers for the preflight, the client library (XHR in the previous example) is not allowed to perform the actual request.
* If the preflight response is correct and complete, then the client library  executes the actual request, which includes certain CORS headers. 
+
The client library then validates the CORS headers of the response. If some of the required headers are missing, then again the client library is obliged to block the response from reaching the client, which is usually a web page.

The following section details the headers for the request and response for the CORS algorithm.

== CORS Request Headers

* Origin: The origin making the cross origin request.
* Access-Control-Request-Method:  The method that is invoked in the actual request . This header is sent in the preflight request.
* Access-Control-Request-Headers: Custom headers that are sent in the actual request. This header is sent in the preflight request.

[NOTE]

For the GET or HEAD methods, the standard defines a specific list of headers that are considered as ‘simple’ and that do not need to perform a preflight. For headers considered as ‘custom’  by the standard, a preflight is executed for GET and HEAD requests. See the example of XHR to validate the path in which the client does not have to perform a preflight.

== CORS Response Headers
	
The headers included in a response differs based on whether the request is a preflight or an actual request:

* Access-Control-Allow-Origin: Obligatory in every response.
+
If this header is not present in the response, the browser or client library blocks the response from reaching the web page. The wildcard “*” can be used to represent any origin.
* Access-Control-Allow-Methods: Allowed methods that can be executed.
+
This headers is returned in the OPTIONS request (preflight). The server might respond with a list of allowed methods, delegating the validation task of whether its actual request is supported to the client.
* Access-Control-Allow-Headers: Allowed headers in the actual request.
+ 
This header works analogous to Access-Control-Allow-Methods.
* Access-Control-Allow-Credentials: Notifies the client, with a Boolean value, whether the actual request can be made with a cookie.
* Access-Control-Expose-Headers: Notifies the browser or client library the list of  headers that can be accessed by  the web page that executed the request. 
+
The HTTP library doing the CORS request, will only show the expose headers to the web page. This allows further filtering of the headers for privacy.
* Access-Control-Max-Age: Notifies the client the number of seconds during which the browser can avoid performing a second preflight for the same request. 

== Public resource

If you need to bypass the SOP of the browser, MuleSoft provides you the option of configuring a public resource that enables the API gateway policy to mirror the preflight data in the response. This also ensures that the actual request is correctly updated with all the CORS headers, such that the browser accepts the response. 

//Mariano--is it sin

== Ordering

By design, the CORS policy is always applied first in order by API gateway and you cannot change this order of execution. If a protected request using OPTIONS is sent to an application that has the CORS policy applied, the request does not reach the protected resource. According to the https://fetch.spec.whatwg.org/#resource-preflight-requests[CORS specification], all OPTIONS requests are considered preflight.

== Groups

If the public resource option is not a strict enough configuration for your environment, you can define multiple groups for the different origins that query your API. Each group applies to a list of origins and can specify different methods, headers, preflight caching time, and expose headers.

== Wildcards on configuration

Wildcards are accepted in the Origins and Headers sections for a group configuration. Use this configuration, for example, when you need a public resource but restricting the accepted HTTP methods. For both sections, an asterisk “*” is the wildcard. 

If you have configured multiple groups and one of the groups uses a wildcard origin, the none-wildcard ones override the wildcard configuration for the specific origins defined in those groups.

== CORS does not seem to be applied

If you use tools, such as curl or Postman to test the CORS policy, neither does the tool add the CORS request headers, nor does it perform the preemptive preflight request in case of a complex request.

If no CORS headers are sent or improper headers are used, API gateway CORS policy does not add any CORS response headers and it appears as the policy is not applied. Ensure that you use the libraries that implement the CORS protocol for you, or review the specification to ensure that you are configuring the correct headers.

//image::cors-policy.png[]

== Configuring CORS for non-API Gateway Mule Environments

If your Mule runtime engine (Mule) is not enabled with API gateway capabilities and you need to implement the CORS functionality, you can use the CORS Interceptor. The CORS Interceptor is an element in the HTTP Listener configuration made available in Mule 4.0.

The CORS configuration differs based on whether you leverage the CORS policy capabilities as a public resource or as a selected group of origins.

For the Selected Group of Origins structure, the following example shows the elements that might be configured:

[source, XML,linenums]
----
<http:listener-interceptors>
   <http:cors-interceptor allowCredentials="optional boolean value (true/false)">
       <http:origins> (collection of origins)
           <http:origin url="http://origin.com" accessControlMaxAge="integer value">
               <http:allowed-methods>
                   <http:method methodName="method 1"/>
	    ...
                   <http:method methodName="method n"/>
               </http:allowed-methods>
               <http:allowed-headers>
                   <http:header headerName="header 1"/>
 	    ...
                   <http:header headerName="header n"/>
               </http:allowed-headers>
               <http:expose-headers>
                   <http:header headerName="header 1"/>
	    ...
                   <http:header headerName="header n"/>
               </http:expose-headers>
           </http:origin>
       </http:origins>
   </http:cors-interceptor>
</http:listener-interceptors>
----

For the Public Resource structure, the following example shows the elements that might be configured:

[source, XML,linenums]
----
<http:listener-interceptors>
   <http:cors-interceptor allowCredentials="optional boolean value (true/false)">
       <http:origins>
           <http:public-resource/>
       </http:origins>
   </http:cors-interceptor>
</http:listener-interceptors>
----

// == Disabling Same-Origin Restrictions in Your Browser

// If you cannot implement CORS for your API, you might need to disable the same-origin restrictions in your browser to call an inaccessible API. How you modify your browser to perform this action depends on the browser you are using. 

// However, before you modify your browser settings, be sure to consider the potential security implications and restrict changes to your own web pages to avoid external threats. As a best practice, you must use these browser settings only for testing in your own web pages.

// === Disable Same-Origin Restrictions on Google Chrome for Mac OS X

// To disable same-origin restrictions on Google Chrome for Mac OS X:

// . Open a new Terminal window and run the following command: 
// +
// `open -a Google\ Chrome --args --disable-web-security`.
// . Press *Enter*.

// === Disable Same-Origin Restrictions on Google Chrome for Windows

// To disable same-origin restrictions on Google Chrome for Windows:

// . Open a Command prompt window.
// . Navigate to the location of the Chrome executable file (Chrome.exe).
// . Run the following command: 
// +
// `chrome.exe --disable-web-security`.
// . Press *Enter*.

// === Disable Same-Origin Restrictions on Internet Explorer

// To disable same-origin restrictions on Internet Explorer:

// . Navigate to *Internet Properties* > *Security* > *Custom Level in Security Level for this Zone* > *Miscellaneous*.
// . Enable the *Enable Access to Data Sources Across Domains* option to access data sources across domains.

== Configuring Policy Parameters

When you apply the policy to your API from the UI, the following parameters are displayed:

[%header%autowidth.spread,cols="a,a,a"]

|===
| Element | Description | Required?
| Public resource | Whether the CORS configuration is to be applied as a public resource (default) | Yes
| Default group | Whether the CORS configuration is to be applied only to specific resources (requires unselecting *Public resource* | No
| Support credentials | Whether the policy supports credentials, such as cookies, authorization headers, and TLS client certificates | No
|===


== See Also

* xref:cors-policy.adoc[Applying and Editing a CORS Policy]
* https://www.w3.org/TR/cors/[Cross-Origin Resource Sharing W3C Recommendation 16 January 2014]
* https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests[Preflight request]
* https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Requests_with_credentials[Mozilla's Request with credentials]
* xref:release-notes::policies/cors-policy-release-notes.adoc[CORS Policy Release Notes]
